THREE.OBJLoader=function(){function a(){var a={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materialLibraries:[],startObject:function(a,b){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=a,void(this.object.fromDeclaration=!1!==b);var c=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:a||"",fromDeclaration:!1!==b,geometry:{vertices:[],normals:[],colors:[],uvs:[]},materials:[],smooth:!0,startMaterial:function(a,b){var c=this._finalize(!1);c&&(c.inherited||0>=c.groupCount)&&this.materials.splice(c.index,1);var d={index:this.materials.length,name:a||"",mtllib:Array.isArray(b)&&0<b.length?b[b.length-1]:"",smooth:void 0===c?this.smooth:c.smooth,groupStart:void 0===c?0:c.groupEnd,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(a){var b={index:"number"==typeof a?a:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return b.clone=this.clone.bind(b),b}};return this.materials.push(d),d},currentMaterial:function(){return 0<this.materials.length?this.materials[this.materials.length-1]:void 0},_finalize:function(a){var b=this.currentMaterial();if(b&&-1===b.groupEnd&&(b.groupEnd=this.geometry.vertices.length/3,b.groupCount=b.groupEnd-b.groupStart,b.inherited=!1),a&&1<this.materials.length)for(var c=this.materials.length-1;0<=c;c--)0>=this.materials[c].groupCount&&this.materials.splice(c,1);return a&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),b}},c&&c.name&&"function"==typeof c.clone){var d=c.clone(0);d.inherited=!0,this.object.materials.push(d)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(a,b){var c=parseInt(a,10);return 3*(0<=c?c-1:c+b/3)},parseNormalIndex:function(a,b){var c=parseInt(a,10);return 3*(0<=c?c-1:c+b/3)},parseUVIndex:function(a,b){var c=parseInt(a,10);return 2*(0<=c?c-1:c+b/2)},addVertex:function(d,a,b){var c=this.vertices,e=this.object.geometry.vertices;e.push(c[d+0],c[d+1],c[d+2]),e.push(c[a+0],c[a+1],c[a+2]),e.push(c[b+0],c[b+1],c[b+2])},addVertexPoint:function(b){var a=this.vertices,c=this.object.geometry.vertices;c.push(a[b+0],a[b+1],a[b+2])},addVertexLine:function(b){var a=this.vertices,c=this.object.geometry.vertices;c.push(a[b+0],a[b+1],a[b+2])},addNormal:function(d,a,b){var c=this.normals,e=this.object.geometry.normals;e.push(c[d+0],c[d+1],c[d+2]),e.push(c[a+0],c[a+1],c[a+2]),e.push(c[b+0],c[b+1],c[b+2])},addColor:function(d,a,b){var c=this.colors,e=this.object.geometry.colors;e.push(c[d+0],c[d+1],c[d+2]),e.push(c[a+0],c[a+1],c[a+2]),e.push(c[b+0],c[b+1],c[b+2])},addUV:function(d,a,b){var c=this.uvs,e=this.object.geometry.uvs;e.push(c[d+0],c[d+1]),e.push(c[a+0],c[a+1]),e.push(c[b+0],c[b+1])},addUVLine:function(b){var a=this.uvs,c=this.object.geometry.uvs;c.push(a[b+0],a[b+1])},addFace:function(d,a,b,c,e,f,g,h,i){var j=this.vertices.length,k=this.parseVertexIndex(d,j),l=this.parseVertexIndex(a,j),m=this.parseVertexIndex(b,j);if(this.addVertex(k,l,m),void 0!==c&&""!==c){var n=this.uvs.length;k=this.parseUVIndex(c,n),l=this.parseUVIndex(e,n),m=this.parseUVIndex(f,n),this.addUV(k,l,m)}if(void 0!==g&&""!==g){var o=this.normals.length;k=this.parseNormalIndex(g,o),l=g===h?k:this.parseNormalIndex(h,o),m=g===i?k:this.parseNormalIndex(i,o),this.addNormal(k,l,m)}0<this.colors.length&&this.addColor(k,l,m)},addPointGeometry:function(a){this.object.geometry.type="Points";for(var b=this.vertices.length,c=0,d=a.length;c<d;c++)this.addVertexPoint(this.parseVertexIndex(a[c],b))},addLineGeometry:function(a,b){this.object.geometry.type="Line";for(var c=this.vertices.length,d=this.uvs.length,e=0,f=a.length;e<f;e++)this.addVertexLine(this.parseVertexIndex(a[e],c));for(var g=0,f=b.length;g<f;g++)this.addUVLine(this.parseUVIndex(b[g],d))}};return a.startObject("",!1),a}function b(a){this.manager=void 0===a?THREE.DefaultLoadingManager:a,this.materials=null}return b.prototype={constructor:b,load:function(a,b,c,d){var e=this,f=new THREE.FileLoader(e.manager);f.setPath(this.path),f.load(a,function(a){b(e.parse(a))},c,d)},setPath:function(a){this.path=a},setMaterials:function(a){return this.materials=a,this},parse:function(b){console.time("OBJLoader");var c=new a;-1!==b.indexOf("\r\n")&&(b=b.replace(/\r\n/g,"\n")),-1!==b.indexOf("\\\n")&&(b=b.replace(/\\\n/g,""));for(var d=b.split("\n"),e="",f="",g=0,h=[],k="function"==typeof"".trimLeft,m=0,n=d.length;m<n;m++)if(e=d[m],e=k?e.trimLeft():e.trim(),g=e.length,0!==g&&(f=e.charAt(0),"#"!==f))if("v"===f){var o=e.split(/\s+/);switch(o[0]){case"v":c.vertices.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3])),8===o.length&&c.colors.push(parseFloat(o[4]),parseFloat(o[5]),parseFloat(o[6]));break;case"vn":c.normals.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3]));break;case"vt":c.uvs.push(parseFloat(o[1]),parseFloat(o[2]));}}else if("f"===f){for(var p,q=e.substr(1).trim(),r=q.split(/\s+/),s=[],t=0,u=r.length;t<u;t++)if(p=r[t],0<p.length){var v=p.split("/");s.push(v)}for(var w=s[0],t=1,u=s.length-1;t<u;t++){var x=s[t],y=s[t+1];c.addFace(w[0],x[0],y[0],w[1],x[1],y[1],w[2],x[2],y[2])}}else if("l"===f){var z=e.substring(1).trim().split(" "),A=[],B=[];if(-1===e.indexOf("/"))A=z;else for(var C,D=0,E=z.length;D<E;D++)C=z[D].split("/"),""!==C[0]&&A.push(C[0]),""!==C[1]&&B.push(C[1]);c.addLineGeometry(A,B)}else if("p"===f){var q=e.substr(1).trim(),F=q.split(" ");c.addPointGeometry(F)}else if(null!==(h=/^[og]\s*(.+)?/.exec(e))){var G=(" "+h[0].substr(1).trim()).substr(1);c.startObject(G)}else if(/^usemtl /.test(e))c.object.startMaterial(e.substring(7).trim(),c.materialLibraries);else if(/^mtllib /.test(e))c.materialLibraries.push(e.substring(7).trim());else if("s"===f){if(h=e.split(" "),1<h.length){var H=h[1].trim().toLowerCase();c.object.smooth="0"!==H&&"off"!==H}else c.object.smooth=!0;var I=c.object.currentMaterial();I&&(I.smooth=c.object.smooth)}else{if("\0"===e)continue;throw new Error("THREE.OBJLoader: Unexpected line: \""+e+"\"")}c.finalize();var J=new THREE.Group;J.materialLibraries=[].concat(c.materialLibraries);for(var m=0,n=c.objects.length;m<n;m++){var K=c.objects[m],L=K.geometry,M=K.materials,N="Line"===L.type,O="Points"===L.type,P=!1;if(0!==L.vertices.length){var Q=new THREE.BufferGeometry;Q.addAttribute("position",new THREE.Float32BufferAttribute(L.vertices,3)),0<L.normals.length?Q.addAttribute("normal",new THREE.Float32BufferAttribute(L.normals,3)):Q.computeVertexNormals(),0<L.colors.length&&(P=!0,Q.addAttribute("color",new THREE.Float32BufferAttribute(L.colors,3))),0<L.uvs.length&&Q.addAttribute("uv",new THREE.Float32BufferAttribute(L.uvs,2));for(var R=[],S=0,T=M.length;S<T;S++){var U=M[S],I=void 0;if(null!==this.materials)if(I=this.materials.create(U.name),N&&I&&!(I instanceof THREE.LineBasicMaterial)){var V=new THREE.LineBasicMaterial;V.copy(I),V.lights=!1,I=V}else if(O&&I&&!(I instanceof THREE.PointsMaterial)){var W=new THREE.PointsMaterial({size:10,sizeAttenuation:!1});V.copy(I),I=W}I||(I=N?new THREE.LineBasicMaterial:O?new THREE.PointsMaterial({size:1,sizeAttenuation:!1}):new THREE.MeshPhongMaterial,I.name=U.name),I.flatShading=!U.smooth,I.vertexColors=P?THREE.VertexColors:THREE.NoColors,R.push(I)}var X;if(1<R.length){for(var U,S=0,T=M.length;S<T;S++)U=M[S],Q.addGroup(U.groupStart,U.groupCount,S);X=N?new THREE.LineSegments(Q,R):O?new THREE.Points(Q,R):new THREE.Mesh(Q,R)}else X=N?new THREE.LineSegments(Q,R[0]):O?new THREE.Points(Q,R[0]):new THREE.Mesh(Q,R[0]);X.name=K.name,J.add(X)}}return console.timeEnd("OBJLoader"),J}},b}();THREE.BufferGeometryUtils={computeTangents:function(a){function b(d,a,b){s.fromArray(g,3*d),u.fromArray(g,3*a),v.fromArray(g,3*b),x.fromArray(k,2*d),y.fromArray(k,2*a),z.fromArray(k,2*b),u.sub(s),v.sub(s),y.sub(x),z.sub(x);var c=1/(y.x*z.y-z.x*y.y);isFinite(c)&&(A.copy(u).multiplyScalar(z.y).addScaledVector(v,-y.y).multiplyScalar(c),B.copy(v).multiplyScalar(y.x).addScaledVector(u,-z.x).multiplyScalar(c),o[d].add(A),o[a].add(A),o[b].add(A),p[d].add(B),p[a].add(B),p[b].add(B))}function c(a){N.fromArray(h,3*a),n.copy(N),J=o[a],L.copy(J),L.sub(N.multiplyScalar(N.dot(J))).normalize(),M.crossVectors(n,J),K=M.dot(p[a]),I=0>K?-1:1,m[4*a]=L.x,m[4*a+1]=L.y,m[4*a+2]=L.z,m[4*a+3]=I}var d=a.index,e=a.attributes;if(null===d||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");var f=d.array,g=e.position.array,h=e.normal.array,k=e.uv.array,l=g.length/3;e.tangent===void 0&&a.setAttribute("tangent",new THREE.BufferAttribute(new Float32Array(4*l),4));for(var m=e.tangent.array,o=[],p=[],q=0;q<l;q++)o[q]=new THREE.Vector3,p[q]=new THREE.Vector3;var s=new THREE.Vector3,u=new THREE.Vector3,v=new THREE.Vector3,x=new THREE.Vector2,y=new THREE.Vector2,z=new THREE.Vector2,A=new THREE.Vector3,B=new THREE.Vector3,C=a.groups;0===C.length&&(C=[{start:0,count:f.length}]);for(var q=0,D=C.length;q<D;++q)for(var r=C[q],E=r.start,F=r.count,G=E,H=E+F;G<H;G+=3)b(f[G+0],f[G+1],f[G+2]);for(var I,J,K,L=new THREE.Vector3,M=new THREE.Vector3,N=new THREE.Vector3,n=new THREE.Vector3,q=0,D=C.length;q<D;++q)for(var r=C[q],E=r.start,F=r.count,G=E,H=E+F;G<H;G+=3)c(f[G+0]),c(f[G+1]),c(f[G+2])},mergeBufferGeometries:function(a,b){for(var c=null!==a[0].index,d=new Set(Object.keys(a[0].attributes)),e=new Set(Object.keys(a[0].morphAttributes)),f={},g={},h=a[0].morphTargetsRelative,k=new THREE.BufferGeometry,l=0,m=0;m<a.length;++m){var n=a[m],o=0;if(c!==(null!==n.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(var p in n.attributes){if(!d.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". All geometries must have compatible attributes; make sure \""+p+"\" attribute exists among all geometries, or in none of them."),null;void 0===f[p]&&(f[p]=[]),f[p].push(n.attributes[p]),o++}if(o!==d.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". Make sure all geometries have the same number of attributes."),null;if(h!==n.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(var p in n.morphAttributes){if(!e.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===g[p]&&(g[p]=[]),g[p].push(n.morphAttributes[p])}if(k.userData.mergedUserData=k.userData.mergedUserData||[],k.userData.mergedUserData.push(n.userData),b){var q;if(c)q=n.index.count;else if(void 0!==n.attributes.position)q=n.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". The geometry must have either an index or a position attribute"),null;k.addGroup(l,q,m),l+=q}}if(c){for(var r,s=0,t=[],m=0;m<a.length;++m){r=a[m].index;for(var u=0;u<r.count;++u)t.push(r.getX(u)+s);s+=a[m].attributes.position.count}k.setIndex(t)}for(var p in f){var v=this.mergeBufferAttributes(f[p]);if(!v)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+p+" attribute."),null;k.setAttribute(p,v)}for(var p in g){var w=g[p][0].length;if(0===w)break;k.morphAttributes=k.morphAttributes||{},k.morphAttributes[p]=[];for(var x,m=0;m<w;++m){x=[];for(var u=0;u<g[p].length;++u)x.push(g[p][u][m]);var y=this.mergeBufferAttributes(x);if(!y)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+p+" morphAttribute."),null;k.morphAttributes[p].push(y)}}return k},mergeBufferAttributes:function(a){for(var b,c,d,e,f=0,g=0;g<a.length;++g){if(e=a[g],e.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===b&&(b=e.array.constructor),b!==e.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===c&&(c=e.itemSize),c!==e.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===d&&(d=e.normalized),d!==e.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;f+=e.array.length}for(var h=new b(f),j=0,g=0;g<a.length;++g)h.set(a[g].array,j),j+=a[g].array.length;return new THREE.BufferAttribute(h,c,d)},interleaveAttributes:function(a){for(var b,d,e=0,f=0,g=0,h=a.length;g<h;++g){if(d=a[g],void 0===b&&(b=d.array.constructor),b!==d.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;e+=d.array.length,f+=d.itemSize}for(var m=new THREE.InterleavedBuffer(new b(e),f),n=0,o=[],p=["getX","getY","getZ","getW"],q=["setX","setY","setZ","setW"],r=0,h=a.length;r<h;r++){var d=a[r],s=d.itemSize,t=d.count,u=new THREE.InterleavedBufferAttribute(m,s,n,d.normalized);o.push(u),n+=s;for(var v=0;v<t;v++)for(var w=0;w<s;w++)u[q[w]](v,d[p[w]](v))}return o},estimateBytesUsed:function(a){var b=0;for(var c in a.attributes){var d=a.getAttribute(c);b+=d.count*d.itemSize*d.array.BYTES_PER_ELEMENT}var e=a.getIndex();return b+=e?e.count*e.itemSize*e.array.BYTES_PER_ELEMENT:0,b},mergeVertices:function(a,b=1e-4){b=Math.max(b,Number.EPSILON);for(var c,d={},e=a.getIndex(),f=a.getAttribute("position"),g=e?e.count:f.count,h=0,n=Object.keys(a.attributes),o={},p={},q=[],r=["getX","getY","getZ","getW"],s=0,t=n.length;s<t;s++){c=n[s],o[c]=[];var u=a.morphAttributes[c];u&&(p[c]=Array(u.length).fill().map(()=>[]))}for(var v=Math.log10(1/b),w=Math.pow(10,v),s=0;s<g;s++){for(var x=e?e.getX(s):s,y="",z=0,t=n.length;z<t;z++)for(var c=n[z],A=a.getAttribute(c),B=A.itemSize,C=0;C<B;C++)y+=`${~~(A[r[C]](x)*w)},`;if(y in d)q.push(d[y]);else{for(var z=0,t=n.length;z<t;z++)for(var D,c=n[z],A=a.getAttribute(c),u=a.morphAttributes[c],B=A.itemSize,E=o[c],F=p[c],C=0;C<B;C++)if(D=r[C],E.push(A[D](x)),u)for(var G=0,H=u.length;G<H;G++)F[G].push(u[G][D](x));d[y]=h,q.push(h),h++}}const I=a.clone();for(var s=0,t=n.length;s<t;s++){var c=n[s],J=a.getAttribute(c),K=new J.array.constructor(o[c]),A=new THREE.BufferAttribute(K,J.itemSize,J.normalized);if(I.setAttribute(c,A),c in p)for(var z=0;z<p[c].length;z++){var L=a.morphAttributes[c][z],K=new L.array.constructor(p[c][z]),M=new THREE.BufferAttribute(K,L.itemSize,L.normalized);I.morphAttributes[c][z]=M}}return I.setIndex(q),I},toTrianglesDrawMode:function(a,b){if(b===THREE.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),a;if(b===THREE.TriangleFanDrawMode||b===THREE.TriangleStripDrawMode){var c=a.getIndex();if(null===c){var d=[],e=a.getAttribute("position");if(void 0!==e){for(var f=0;f<e.count;f++)d.push(f);a.setIndex(d),c=a.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),a}var g=c.count-2,h=[];if(b===THREE.TriangleFanDrawMode)for(var f=1;f<=g;f++)h.push(c.getX(0)),h.push(c.getX(f)),h.push(c.getX(f+1));else for(var f=0;f<g;f++)0==f%2?(h.push(c.getX(f)),h.push(c.getX(f+1)),h.push(c.getX(f+2))):(h.push(c.getX(f+2)),h.push(c.getX(f+1)),h.push(c.getX(f)));h.length/3!=g&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var j=a.clone();return j.setIndex(h),j.clearGroups(),j}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",b),a}};