let isGhostLoaded=!1;function removeLoader(){const a=document.querySelector("#loader"),b=document.querySelector("#container");a.style.animation="fadeOut 0.375s ease-in-out forwards",b.style.animation="fadeIn 0.75s ease-in-out forwards",a.style.display="none"}function updatePlay(){params.play=!0}function initTexture(){renderer.extensions.get("OES_texture_float")||console.log("No OES_texture_float support for float textures."),0===renderer.capabilities.maxVertexTextures&&console.log("No support for vertex shader textures.");const a=new Float32Array(4*TEXTURE_WIDTH*BITS),b=new THREE.DataTexture(a,TEXTURE_WIDTH,4,THREE.RGBFormat,THREE.FloatType);return b.wrapS=THREE.RepeatWrapping,b.wrapY=THREE.RepeatWrapping,b.magFilter=THREE.LinearFilter,b.needsUpdate=!0,b}function setTextureValue(a,b,c,d,e){const f=texture.image,{width:g,height:h,data:j}=f,k=BITS*g*(e||0);j[a*BITS+k+0]=b,j[a*BITS+k+1]=c,j[a*BITS+k+2]=d}function modifyShader(a){a.__ok||(a.__ok=!0,a.onBeforeCompile=a=>{if(!a.__modified){for(var b in a.__modified=!0,uniforms=Object.assign(a.uniforms,{texture:{value:texture},pathOffset:{type:"f",value:0},pathSegment:{type:"f",value:1},spineOffset:{type:"f",value:161},spineLength:{type:"f",value:400},flow:{type:"i",value:1}}),bufferUniforms)updateUniform(b,bufferUniforms[b]);vertexShader=`
        uniform sampler2D texture;

        uniform float pathOffset;
        uniform float pathSegment;
        uniform float spineOffset;
        uniform float spineLength;
        uniform int flow;

        float textureLayers = 4.; // look up takes (i + 0.5) / textureLayers

        ${a.vertexShader}
        `,vertexShader=vertexShader.replace("#include <defaultnormal_vertex>",`
            vec4 worldPos = modelMatrix * vec4(position, 1.);

            bool bend = flow > 0;
            float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;
            float xWeight = bend ? 0. : 1.;
            float mt = spinePortion * pathSegment + pathOffset;

            vec3 spinePos = texture2D(texture, vec2(mt, (0.5) / textureLayers)).xyz;
            vec3 a = texture2D(texture, vec2(mt, (1. + 0.5) / textureLayers)).xyz;
            vec3 b = texture2D(texture, vec2(mt, (2. + 0.5) / textureLayers)).xyz;
            vec3 c = texture2D(texture, vec2(mt, (3. + 0.5) / textureLayers)).xyz;
            mat3 basis = mat3(a, b, c);

            vec3 transformed = basis
                * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)
                + spinePos;

            vec3 transformedNormal = normalMatrix * (basis * objectNormal);
            `).replace("#include <begin_vertex>","").replace("#include <project_vertex>",`
            vec4 mvPosition = viewMatrix * vec4( transformed, 1.0 );
            // vec4 mvPosition = viewMatrix * worldPos;
            gl_Position = projectionMatrix * mvPosition;
            `),a.vertexShader=vertexShader}})}function initPathShader(){customMaterial=new THREE.MeshLambertMaterial({color:14932968,emissive:13739498,emissiveIntensity:.45,side:THREE.DoubleSide}),modifyShader(customMaterial),texture=initTexture(),activate(null,a=>{console.log(a),onLoad(a)});var a=new THREE.OBJLoader;a.load("https://raw.githubusercontent.com/aniarubin/ghost-threejs/master/ghost-optimized2.obj",onLoad,function(a){console.log(100*(a.loaded/a.total)+"% loaded")},function(){console.log("An error happened")})}function onLoad(a){ghost&&scene.remove(ghost),ghost=a,a.traverse(function(a){if(a instanceof THREE.Mesh){var b=new THREE.Geometry().fromBufferGeometry(a.geometry);b.mergeVertices(),b.computeVertexNormals(),a.geometry=new THREE.BufferGeometry().fromGeometry(b),a.material=customMaterial,a.castShadow=!0}}),geoms=ghost.children.map(a=>a.geometry),bbs=geoms.map(a=>(a.computeBoundingBox(),a.boundingBox)),console.log("boundingbox",bbs),referenceGeometry.vertices[0].set(Math.min(...bbs.map(a=>a.min.x)),Math.min(...bbs.map(a=>a.min.y)),Math.min(...bbs.map(a=>a.min.z))),referenceGeometry.vertices[1].set(Math.max(...bbs.map(a=>a.max.x)),Math.max(...bbs.map(a=>a.max.y)),Math.max(...bbs.map(a=>a.max.z))),updateModel(),updatePlay(),console.log("Ghost is loaded"),isGhostLoaded=!0,removeLoader(),scene.add(a)}